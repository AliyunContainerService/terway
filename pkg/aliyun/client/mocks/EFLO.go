// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/AliyunContainerService/terway/pkg/aliyun/client"

	eflo "github.com/aliyun/alibaba-cloud-sdk-go/services/eflo"

	mock "github.com/stretchr/testify/mock"

	wait "k8s.io/apimachinery/pkg/util/wait"
)

// EFLO is an autogenerated mock type for the EFLO type
type EFLO struct {
	mock.Mock
}

// AssignLeniPrivateIPAddress2 provides a mock function with given fields: ctx, opts
func (_m *EFLO) AssignLeniPrivateIPAddress2(ctx context.Context, opts ...client.AssignPrivateIPAddressOption) ([]client.IPSet, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssignLeniPrivateIPAddress2")
	}

	var r0 []client.IPSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.AssignPrivateIPAddressOption) ([]client.IPSet, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.AssignPrivateIPAddressOption) []client.IPSet); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.IPSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.AssignPrivateIPAddressOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachHDENI provides a mock function with given fields: ctx, opts
func (_m *EFLO) AttachHDENI(ctx context.Context, opts ...client.AttachNetworkInterfaceOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachHDENI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.AttachNetworkInterfaceOption) error); ok {
		r0 = rf(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AttachLeni provides a mock function with given fields: ctx, opts
func (_m *EFLO) AttachLeni(ctx context.Context, opts ...client.AttachNetworkInterfaceOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachLeni")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.AttachNetworkInterfaceOption) error); ok {
		r0 = rf(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateElasticNetworkInterfaceV2 provides a mock function with given fields: ctx, opts
func (_m *EFLO) CreateElasticNetworkInterfaceV2(ctx context.Context, opts ...client.CreateNetworkInterfaceOption) (*client.NetworkInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateElasticNetworkInterfaceV2")
	}

	var r0 *client.NetworkInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.CreateNetworkInterfaceOption) (*client.NetworkInterface, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.CreateNetworkInterfaceOption) *client.NetworkInterface); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.NetworkInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.CreateNetworkInterfaceOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHDENI provides a mock function with given fields: ctx, opts
func (_m *EFLO) CreateHDENI(ctx context.Context, opts ...client.CreateNetworkInterfaceOption) (*client.NetworkInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHDENI")
	}

	var r0 *client.NetworkInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.CreateNetworkInterfaceOption) (*client.NetworkInterface, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.CreateNetworkInterfaceOption) *client.NetworkInterface); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.NetworkInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.CreateNetworkInterfaceOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteElasticNetworkInterface provides a mock function with given fields: ctx, eniID
func (_m *EFLO) DeleteElasticNetworkInterface(ctx context.Context, eniID string) error {
	ret := _m.Called(ctx, eniID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteElasticNetworkInterface")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, eniID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteHDENI provides a mock function with given fields: ctx, eniID
func (_m *EFLO) DeleteHDENI(ctx context.Context, eniID string) error {
	ret := _m.Called(ctx, eniID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHDENI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, eniID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DescribeHDENI provides a mock function with given fields: ctx, opts
func (_m *EFLO) DescribeHDENI(ctx context.Context, opts ...client.DescribeNetworkInterfaceOption) ([]*client.NetworkInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHDENI")
	}

	var r0 []*client.NetworkInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DescribeNetworkInterfaceOption) ([]*client.NetworkInterface, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DescribeNetworkInterfaceOption) []*client.NetworkInterface); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*client.NetworkInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.DescribeNetworkInterfaceOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeLeniNetworkInterface provides a mock function with given fields: ctx, opts
func (_m *EFLO) DescribeLeniNetworkInterface(ctx context.Context, opts ...client.DescribeNetworkInterfaceOption) ([]*client.NetworkInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeLeniNetworkInterface")
	}

	var r0 []*client.NetworkInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DescribeNetworkInterfaceOption) ([]*client.NetworkInterface, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DescribeNetworkInterfaceOption) []*client.NetworkInterface); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*client.NetworkInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.DescribeNetworkInterfaceOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DetachHDENI provides a mock function with given fields: ctx, opts
func (_m *EFLO) DetachHDENI(ctx context.Context, opts ...client.DetachNetworkInterfaceOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachHDENI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DetachNetworkInterfaceOption) error); ok {
		r0 = rf(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DetachLeni provides a mock function with given fields: ctx, opts
func (_m *EFLO) DetachLeni(ctx context.Context, opts ...client.DetachNetworkInterfaceOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DetachLeni")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.DetachNetworkInterfaceOption) error); ok {
		r0 = rf(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetNodeInfoForPod provides a mock function with given fields: ctx, nodeID
func (_m *EFLO) GetNodeInfoForPod(ctx context.Context, nodeID string) (*eflo.Content, error) {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeInfoForPod")
	}

	var r0 *eflo.Content
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*eflo.Content, error)); ok {
		return rf(ctx, nodeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *eflo.Content); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eflo.Content)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, nodeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListLeniPrivateIPAddresses provides a mock function with given fields: ctx, eniID, ipName, ipAddress
func (_m *EFLO) ListLeniPrivateIPAddresses(ctx context.Context, eniID string, ipName string, ipAddress string) (*eflo.Content, error) {
	ret := _m.Called(ctx, eniID, ipName, ipAddress)

	if len(ret) == 0 {
		panic("no return value specified for ListLeniPrivateIPAddresses")
	}

	var r0 *eflo.Content
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*eflo.Content, error)); ok {
		return rf(ctx, eniID, ipName, ipAddress)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *eflo.Content); ok {
		r0 = rf(ctx, eniID, ipName, ipAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eflo.Content)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, eniID, ipName, ipAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnAssignLeniPrivateIPAddresses2 provides a mock function with given fields: ctx, eniID, ips
func (_m *EFLO) UnAssignLeniPrivateIPAddresses2(ctx context.Context, eniID string, ips []client.IPSet) error {
	ret := _m.Called(ctx, eniID, ips)

	if len(ret) == 0 {
		panic("no return value specified for UnAssignLeniPrivateIPAddresses2")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []client.IPSet) error); ok {
		r0 = rf(ctx, eniID, ips)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnassignLeniPrivateIPAddress provides a mock function with given fields: ctx, eniID, ipName
func (_m *EFLO) UnassignLeniPrivateIPAddress(ctx context.Context, eniID string, ipName string) error {
	ret := _m.Called(ctx, eniID, ipName)

	if len(ret) == 0 {
		panic("no return value specified for UnassignLeniPrivateIPAddress")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, eniID, ipName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitForLeniNetworkInterface provides a mock function with given fields: ctx, eniID, status, backoff, ignoreNotExist
func (_m *EFLO) WaitForLeniNetworkInterface(ctx context.Context, eniID string, status string, backoff wait.Backoff, ignoreNotExist bool) (*client.NetworkInterface, error) {
	ret := _m.Called(ctx, eniID, status, backoff, ignoreNotExist)

	if len(ret) == 0 {
		panic("no return value specified for WaitForLeniNetworkInterface")
	}

	var r0 *client.NetworkInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, wait.Backoff, bool) (*client.NetworkInterface, error)); ok {
		return rf(ctx, eniID, status, backoff, ignoreNotExist)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, wait.Backoff, bool) *client.NetworkInterface); ok {
		r0 = rf(ctx, eniID, status, backoff, ignoreNotExist)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.NetworkInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, wait.Backoff, bool) error); ok {
		r1 = rf(ctx, eniID, status, backoff, ignoreNotExist)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEFLO creates a new instance of EFLO. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEFLO(t interface {
	mock.TestingT
	Cleanup(func())
}) *EFLO {
	mock := &EFLO{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
