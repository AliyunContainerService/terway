#!/bin/bash

# Terway 部署脚本
# 该脚本从 Terraform 状态读取配置，并使用 Helm 部署 Terway 组件

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TERRAFORM_STATE_FILE="${SCRIPT_DIR}/terraform.tfstate"
VALUES_OUTPUT_FILE="${SCRIPT_DIR}/terway-values.yaml"

# 动态获取项目根目录和 Chart 路径
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd)"
CHART_PATH="${PROJECT_ROOT}/charts/terway"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查依赖
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed"
        exit 1
    fi

    if ! command -v helm &> /dev/null; then
        log_error "helm is not installed"
        exit 1
    fi

    if ! command -v jq &> /dev/null; then
        log_error "jq is not installed"
        exit 1
    fi

    log_info "All dependencies are available"
}

# 检查 kubeconfig 文件
check_kubeconfig() {
    # 如果 KUBECONFIG_FILE 未设置，尝试从 terraform 读取
    if [[ -z "${KUBECONFIG_FILE}" ]] || [[ ! -f "${KUBECONFIG_FILE}" ]]; then
        # 尝试查找最新的 kubeconfig 文件
        # shellcheck disable=SC2012
        KUBECONFIG_FILE=$(ls -t "${SCRIPT_DIR}"/kubeconfig-* 2>/dev/null | head -1)
    fi

    if [[ -z "${KUBECONFIG_FILE}" ]] || [[ ! -f "${KUBECONFIG_FILE}" ]]; then
        log_error "Kubeconfig file not found"
        log_info "Please run 'terraform apply' first to generate the kubeconfig"
        exit 1
    fi

    log_info "Kubeconfig file found: ${KUBECONFIG_FILE}"
}

# 从 Terraform 状态读取配置
read_terraform_config() {
    log_info "Reading Terraform configuration..."

    if [[ ! -f "${TERRAFORM_STATE_FILE}" ]]; then
        log_error "Terraform state file not found: ${TERRAFORM_STATE_FILE}"
        log_info "Please run 'terraform apply' first"
        exit 1
    fi

    # 从 terraform.tfstate 读取配置
    CLUSTER_ID=$(jq -r '.resources[] | select(.type=="alicloud_cs_managed_kubernetes" and .name=="default") | .instances[0].attributes.id' "${TERRAFORM_STATE_FILE}")
    REGION=$(jq -r '.variables.region_id.value // "cn-hangzhou"' "${TERRAFORM_STATE_FILE}")
    SERVICE_CIDR=$(jq -r '.variables.service_cidr.value // "192.168.0.0/16"' "${TERRAFORM_STATE_FILE}")

    # 获取 VPC ID
    VPC_ID=$(jq -r '.resources[] | select(.type=="alicloud_vpc" and .name=="default") | .instances[0].attributes.id' "${TERRAFORM_STATE_FILE}")

    # 获取节点交换机 ID
    VSWITCH_IDS=$(jq -r '.resources[] | select(.type=="alicloud_vswitch" and .name=="vswitches") | .instances[].attributes.id' "${TERRAFORM_STATE_FILE}" | tr '\n' ',' | sed 's/,$//')

    # 获取 Terway 交换机 ID
    TERWAY_VSWITCH_IDS=$(jq -r '.resources[] | select(.type=="alicloud_vswitch" and .name=="terway_vswitches") | .instances[].attributes.id' "${TERRAFORM_STATE_FILE}" | tr '\n' ',' | sed 's/,$//')

    # 获取安全组 ID (从集群信息)
    SECURITY_GROUP_ID=$(jq -r '.resources[] | select(.type=="alicloud_cs_managed_kubernetes" and .name=="default") | .instances[0].attributes.security_group_id' "${TERRAFORM_STATE_FILE}")

    # 获取 kubeconfig 文件名
    KUBECONFIG_NAME=$(jq -r '.variables.k8s_name_prefix.value // "tf-ack-hangzhou-terway"' "${TERRAFORM_STATE_FILE}")
    KUBECONFIG_SUFFIX=$(jq -r '.resources[] | select(.type=="random_string" and .name=="cluster_suffix") | .instances[0].attributes.result' "${TERRAFORM_STATE_FILE}")
    KUBECONFIG_FILE="${SCRIPT_DIR}/kubeconfig-${KUBECONFIG_NAME}-${KUBECONFIG_SUFFIX}"

    log_info "Cluster ID: ${CLUSTER_ID}"
    log_info "Region: ${REGION}"
    log_info "VPC ID: ${VPC_ID}"
    log_info "Service CIDR: ${SERVICE_CIDR}"
    log_info "Node VSwitch IDs: ${VSWITCH_IDS}"
    log_info "Terway VSwitch IDs: ${TERWAY_VSWITCH_IDS}"
    log_info "Security Group ID: ${SECURITY_GROUP_ID}"
    log_info "Kubeconfig file: ${KUBECONFIG_FILE}"
}

# 生成 Helm values 文件
generate_values_file() {
    log_info "Generating Helm values file..."

    # 构建 vSwitch IDs 按可用区分组 (生成 YAML 格式)
    VSWITCH_YAML=$(jq -r -n --argjson state "$(cat "${TERRAFORM_STATE_FILE}")" '
        $state.resources
        | map(select(.type == "alicloud_vswitch" and .name == "terway_vswitches"))
        | map(.instances[])
        | group_by(.attributes.zone_id // .attributes.availability_zone)
        | map({
            zone: (.[0].attributes.zone_id // .attributes.availability_zone),
            ids: [.[].attributes.id]
          })
        | map("    " + .zone + ":\n" + (.ids | map("      - " + .) | join("\n")))
        | join("\n")
    ')

    # 创建 values 文件
    cat > "${VALUES_OUTPUT_FILE}" << EOF
# Terway Helm Values - Generated by deploy-terway.sh
# Generated at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

centralizedIPAM: true

terway:
  image:
    repository: registry-cn-hangzhou.ack.aliyuncs.com/acs/terway
    pullPolicy: IfNotPresent
    tag: "v1.16.7"

  daemonMode: ENIMultiIP
  enableDatapathV2: false
  networkPolicyProvider: ebpf
  enableNetworkPolicy: false

  ipStack: ipv4

  # 安全组配置
  securityGroupIDs:
    - "${SECURITY_GROUP_ID}"

  # 交换机配置 (按可用区)
  vSwitchIDs:
${VSWITCH_YAML}

  # Service CIDR
  serviceCIDR: "${SERVICE_CIDR}"

terwayControlplane:
  replicaCount: 1

  image:
    repository: registry-cn-hangzhou.ack.aliyuncs.com/acs/terway-controlplane
    pullPolicy: IfNotPresent
    tag: "v1.16.7"

  # 集群配置
  regionID: "${REGION}"
  clusterID: "${CLUSTER_ID}"
  vpcID: "${VPC_ID}"

  # 控制器配置
  controllers:
    - pod-eni
    - pod
    - pod-networking
    - node
    - multi-ip-node
    - multi-ip-pod

  # Credential path for addon token
  credentialPath: "/var/addon/token-config"
EOF

    log_info "Values file generated: ${VALUES_OUTPUT_FILE}"
}

# 部署 Terway
deploy_terway() {
    log_info "Deploying Terway using Helm..."

    # 检查 chart 路径
    if [[ ! -d "${CHART_PATH}" ]]; then
        log_error "Chart path not found: ${CHART_PATH}"
        exit 1
    fi

    # 添加 Helm repo (如果需要)
    # helm repo add ack https://charts.aliyun.com

    # 使用 Helm 部署
    helm upgrade --install terway "${CHART_PATH}" \
        --kubeconfig "${KUBECONFIG_FILE}" \
        --namespace kube-system \
        --values "${VALUES_OUTPUT_FILE}" \
        --create-namespace \
        --timeout 10m0s \
        --wait --wait-for-jobs

    log_info "Terway deployment completed"
}

# 验证部署
verify_deployment() {
    log_info "Verifying Terway deployment..."

    # 等待 pods 就绪
    kubectl --kubeconfig "${KUBECONFIG_FILE}" wait --for=condition=available deployment/terway-controlplane -n kube-system --timeout=300s || true
    kubectl --kubeconfig "${KUBECONFIG_FILE}" wait --for=condition=ready pod -l k8s-app=terway -n kube-system --timeout=300s || true

    # 显示 pods 状态
    log_info "Terway pods status:"
    kubectl --kubeconfig "${KUBECONFIG_FILE}" get pods -n kube-system -l k8s-app=terway

    log_info "Terway-controlplane pods status:"
    kubectl --kubeconfig "${KUBECONFIG_FILE}" get pods -n kube-system -l app=terway-controlplane
}

# 主函数
main() {
    log_info "Starting Terway deployment..."

    check_dependencies
    check_kubeconfig
    read_terraform_config
    generate_values_file

    if [[ "${1:-}" == "--dry-run" ]]; then
        log_info "Dry run mode - skipping deployment"
        log_info "Values file generated: ${VALUES_OUTPUT_FILE}"
        exit 0
    fi

    deploy_terway
    verify_deployment

    log_info "Terway deployment completed successfully!"
}

main "$@"
